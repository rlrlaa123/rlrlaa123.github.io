---
layout:page
title:Javascript Definitive Guide Chapter 3: Data type and value
subtitle:Everything about my programming
img:https://www.google.co.kr/url?sa=i&rct=j&q=&esrc=s&source=images&cd=&cad=rja&uact=8&ved=0ahUKEwjyt7Wr7KLVAhVCoZQKHZibCiwQjRwIBw&url=http%3A%2F%2Fwww.aladin.co.kr%2Fshop%2Fwproduct.aspx%3FItemId%3D2146920&psig=AFQjCNED3TwOK8GNu1hhkruz-stJqF76Cg&ust=1501017567487045
---

## 3장 데이터 타입과 값
#### 3.16 특수한 숫자 값
* infinity: 무한대를 나타내는 특수한 값
* Nan: 숫자가 아닌 특수한 값
	* 수리연산(0 나누기 0 같은)이 정의되지 않은 결과를 산출하거나 에러를 발생시킬 경우에도 특수한 자바스크립트 값이 반환된다. 이를 Nan으로 출력한다.
	* 이를 나타내기 위해선 isNan()이라는 특별한 함수가 필요하다. isNan이 아닌 동시에 무한대나 음의 무한대가 아닌지 여부를 검사한다.

### 3.2 문자열
* javascript는 char 같은 타입이 없다.

#### 3.2.3 문자열 조각
* s.length: 문자열의 길이를 알아낼 수 있다.
* s.charAt(s.length-1): 문자열의 마지막 글자를 가져올 수 있다.
* s.substring(1,4): 두 번째부터 네 번째까지의 문자를 추출할 수 있다.
* i = s.indexOf('a'): 'a' 문자의 위치를 찾아낼 수 있다.

#### 3.2.4 숫자를 문자열로 변환하기
~~~
// 숫자를 문자열로 나타내기
var string_value = String(number);
string_value = number.toString();

// n진법으로 나타내기
var n = 17;
binary_string = n.toString(2);	// "10001"로 평가된다.
octal_string = "0" + n.toString(8);	// "021"로 평가된다.
hex_string = "0x" + n.toString(16);	// "0x11"로 평가된다.

// 반올림
var n = 123456.789
n.isFixed(0);		//"123457"
n.isFixed(2);		//"123456.79"
~~~

#### 3.2.5 문자열을 숫자로 변환하기
~~~
var product = "21" * "2"	// 두 문자열의 곱은 숫자 42가 된다.
var number = Number(string_value);
parseInt("3 blind mice");	// 3을 반환
parseFloat("3.14 meters");	// 3.14를 반환
~~~

#### 3.3.1 불리언 타입 변환 - 자동 형변환
* 불리언 값은 쉽게 다른 타입으로 변환되거나 다른 타입에서 불리언 값으로 변환될 수 있으며 많은 경우 그 변환은 자동으로 수행된다.
	* 만약 불리언 값이 숫자 문맥에서 사용되면 true는 숫자 1로 false는 숫자 0으로 변환된다. 문자열로 마찬가지로 "true", "false"로 형변환한다.
* C 프로그래머들은 불리언 값을 흉내 내기 위해 정수 값을 사용하는 C와는 다르게, 자바스크립트에는 별개의 불리언 데이터 타입이 있다. 반면, 자바는 순수한 데이터 타입으로서 불리언 값이 존재한다.  __그렇다고 하더라도, 자바스크립트의 불리언은 쉽게 형변환이 가능하기 때문에, C의 방식과 더 비슷하다고 볼 수 있다.__

### 3.4 함수
* 자바스크립트의 중요한 특징 중 하나는 __함수도 변수에 담길 수 있다는 것__이다. __즉, 변수나, 배열, 객체에 저장할 수 있으며 다른 함수의 전달인자로 넘겨 줄 수 있다는 것을 의미한다.__

#### 3.4.1 함수 리터럴
* 함수 리터럴이란 __함수 이름을 명시하지 않는 함수이다.__

~~~
function square(x) { return x*x }	// 일반 함수
var square = function(x) { return x*x }	// 리터럴 함수
~~~
* 이름 없는 함수를 프로그램 내에 리터럴 형태로 포함시킬 수 있게 한 최초의 언어인 Lisp 프로그램 언어를 기리는 의미에서 이러한 방식으로 정의된 함수를 람다함수(lambda function)라고 부른다.

### 3.6 배열
* 자바스크립트는 다차원 배열을 지원하지 않는다.
* 배열의 원소들이 모두 동일한 타입을 가질 필요는 없다.

### 3.9 Date 객체

### 3.10 정규 표현식
* /	/ 사이에 정규표현식을 표현한다.

~~~
/^HTML/
/[1-9][0-9]*/
/\bjavascript\b/i
~~~

### 3.12 타입 변환 요약
* javascript 는 필요에 따라 알아서 그 값을 변환하려고 시도한다. 그래서, 문맥을 보고 어떤 타입인지 알 수 있다.

### 3.13 기본 데이터 타입 wrapper 객체
* javascript에서의 string은 객체 표기법으로 다음과 같이 함수들을 불러올 수 있다.

~~~
var s = "abc"
var last_word = s.substring(s.lastIndexOf(" ")+1, s.length);
~~~
* 문자열의 타입을 조사해보면 object가 아니라 string 데이터 타입이라고 뜬다. __그렇다면, 왜 문자열을 조작할 때 객체 표기법을 사용할 수 있는 것일까?__
* 사실, 자바스크립트에는 세 가지 핵심 기본 데이터 타입 각각에 대응되는 클래스가 정의되어 있다. 즉, __Number, String, Boolean 클래스__를 지원해서 이들이 __기본 데이터 타입들을 둘러싸는 wrapper 역활__을 한다.
* 그렇기 때문에, 각 자료형을 불러오면, 그 클래스안에 존재하는 메서드 들과 함께 객체 표기법으로 사용이 가능한 것이다.

### 3.15 값에 의한 vs. 참조에 의한
* by value란 단순한 값의 복사를 뜻한다면,
* by reference는 값에 대한 실제 복사본이 오직 하나만 존재한다. __우리가 조작하는 것은 값에 대한 참조다.__
	* 값이 참조에 의해 조작될 때 변수는 직접 값을 담지 않는다. 단순히 값에 대한 참조를 담을 뿐이다. 복사나 전달, 비교되는 것은 참조다.
	*  따라서 참조에 의한 할당에서는 값에 대한 참조가 할당되며, 값의 복사본이나 값 자체가 할당되지는 않는다.
* 이렇게 자바스크립트에는 두 가지 서로 다른 값 조작 방식이 존재하며, 이 둘을 잘 이해해야 한다. 

#### 3.15.1
* 숫자와 불리언 타입은 기본 타입이다.
	* 이들을 기본 타입으로 취급하는 이유는 정해진 개수의 작은 바이트로 구성되어 있어 자바스크립트 인터프리터가 저수준 오퍼레이션을 통해 손쉽게 조작할 수 있기 때문이다.
* 객체는 참조 타입이다. 객체의 특수한 종류인 배열이나 함수도 마찬가지로 참조 타입이다.
	* 이들 참조 타입은 임의 개수의 프로퍼티나 원소를 포함할 수 있으므로, 크기가 고정된 기본 타입을 조작하듯 쉽게 조작할 수 없다. 객체나 배열 값을 그 크기가 상당히 커질 수 있으므로 이들을 값에 의해 조작할 수는 없다. 그 이유는 이들을 값에 의해 조작하면 복사나 비교작업에 메모리를 비효율적으로 많이 사용해야 하기 때문이다.
* 문자열은 객체가 아니라는 간단한 이유 때문에 자바스크립트에서 보통 기본 타입으로 취급된다. 하지만, 기본 타입 대 참조 타입이라는 이분법에 들어맞지 않아 뒤에 이에 대해 설명하고자 한다.

~~~
var xmas = new Date(2007, 11, 25);
var solstice = xmas;	// 참조에 의한 복사를 수행하면 원본 객체에 대한 새로운 참조를 얻는다.
solstice.setDate(21);
xmas.getDate();	// 원본 값인 25가 아닌 21을 반환한다.

// 객체나 배열이 함수에 전달되는 경우에도 동일하게 적용된다.
// 함수에 배열의 복사본이 아닌 배열에 대한 참조가 전달되었다.
// 따라서 함수는 참조를 통해 배열의 내용을 변경할 수 있고
// 변경사항은 함수가 종료된 후에도 보인다.
function add_to_totals(totals, x)
{
	totals[0] = totals[0] + x;
	totals[1] = totals[1] + x;
	totals[2] = totals[2] + x;
}

(xmas==solstice) // true로 평가된다.

var xmas = new Date(2007, 11, 25);
var solstice_plus_4 = new Date(2007, 11, 25);

(xmas != solstice_plus_4) // true로 평가된다.
~~~

* 참조에 대한 이해를 위해 또 다른 예제를 보자. 이 예제의 함수는 제대로 작동하지 않는다. 그 이유는 이 함수가 배열 그 자체를 변경하기 보다는 배열에 대한 참조를 변경하려고 시도하기 때문이다.
* totals는 참조이기 때문에 totals의 참조가 newtotals로 변하지만, 매개변수를 통해 참조해 바꾸려던 밖의 변수의 값은 변하지 않는 것이다.

~~~
function add_to_totals2(totals, x)
{
	newtotals = new Array(3);
	newtotals[0] = totals[0] + x;
	newtotals[1] = totals[1] + x;
	newtotals[2] = totals[2] + x;
	totals = newtotals; // 이 줄은 함수 외부에 아무런 영향도 주지 않는다.
}
~~~
